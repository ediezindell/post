# 現在のクリップボードの内容でバッファを置換する

```
vim.api.nvim_set_keymap("n", "<leader><C-v>", [[<Cmd>%d | normal! "+P<CR>]], { noremap = true, silent = true })
```

# ESLintでブラウザのグローバル変数をホワイトリストに追加する

[globals](https://www.npmjs.com/package/globals) を使う

```shell
npm i globals
```

```js:eslint.config.mjs
import globals from 'globals'

export default [
  {
    languageOptions: {
      globals: {
        ...globals.browser, // ブラウザ用のグローバル変数の設定を展開
      },
    },
  },
]
```

# grepはマッチ文字列がないとエラー終了する

https://qiita.com/kino-ma/items/224be744989647a34130

`grep` 結果が不要であれば `-q` オプションを付けてif文の中で直接呼び出すのが良さそう

```sh
output="[error] something message"
if echo "$output" | grep -q "error"; then
  echo "something error occurred" >&2
  exit 1
fi
```

# Tailwind CSSで確実に `output.css` にスタイルを出力するには

設定ファイルの `safelist` に追記することで、実際に使われていないクラスを `output.css` に含めることができる

```js:tailwind.config.js
module.exports = {
  safelist: [
    'bg-red-500',
    'text-center',
    'md:text-right',
    {
      pattern: /bg-(red|green|blue)-(100|200|300)/,
      variants: ['hover', 'focus'],
    },
  ],
}
```

# PostgreSQLのWASM版を使ってブラウザ上でDBを扱う

https://github.com/electric-sql/pglite  
https://www.publickey1.jp/blog/24/webassembypostgresqlpglitenodejspostgresqldb.html  
https://developer.mozilla.org/ja/docs/Web/API/IndexedDB_API/Using_IndexedDB

Prismaはまだ対応されていない  
https://github.com/prisma/prisma/pull/23877

以下のようなJavaScriptを書いてscriptタグで読み込ませれば普通に使える

```js
import { PGlite } from "https://cdn.jsdelivr.net/npm/@electric-sql/pglite/dist/index.js";

const db = new PGlite() // in-memory
// const db = new PGlite('idb://my-pgdata') // IndexedDB

const initUserTable = async () => {
  await db.query(`CREATE TABLE IF NOT EXISTS users (
    id SERIAL NOT NULL,
    name VARCHAR(20) NOT NULL,
    created_at TIMESTAMP DEFAULT now(),
    updated_at TIMESTAMP DEFAULT now(),
    PRIMARY KEY (id)
  );`)

  const count = (await db.query("SELECT COUNT(*) FROM users;")).rows[0].count
  if (count === 0) {
    for (let i = 1; i <= 10; i++) {
      await db.query(`INSERT INTO users(name) VALUES('user-${i}')`)
    }
  }
}
await initUserTable();

const result = await db.query("SELECT * FROM users;")
console.table(result.rows)
```

# 既にイベントリスナーが複数登録されているときに、それらよりも前に実行されるイベントリスナーを登録したい

`element.addEventListener()` の第3引数に `true` を指定することで要件を満たせることがある

```js
element.addEventListener('click', clickHandler, true)
```

## 動きを確認してみる

```html
<body>
  <button type="button" id="target">clickme!</button>
</body>
```

```js
const targetElement = document.getElementById('target');

document.addEventListener('click', () => console.log('Document Capturing'), true);
document.addEventListener('click', () => console.log('Document Bubbling'), false);
document.body.addEventListener('click', () => console.log('Body Capturing'), true);
document.body.addEventListener('click', () => console.log('Body Bubbling'), false);
targetElement.addEventListener('click', () => console.log('Target Capturing'), true);
targetElement.addEventListener('click', () => console.log('Target Bubbling'), false);
```

上記のコードで `targetElement` をクリックした場合、実行順序は以下のようになる

1. Document Capturing
1. Body Capturing
1. Target Capturing
1. Target Bubbling
1. Body Bubbling
1. Document Bubbling

- キャプチャリング: 親要素から子要素へ伝播
- バブリング: 子要素から親要素へ伝播

`addEventListener` の第3引数 ( `useCapture` ) 

- `true` : キャプチャリングフェーズで実行する
- `false` : バブリングフェーズで実行する (デフォルト)

第3引数はオブジェクトも受け付けるが、説明は以下のMDN参照ということで省略  
https://developer.mozilla.org/ja/docs/Web/API/EventTarget/addEventListener#options


